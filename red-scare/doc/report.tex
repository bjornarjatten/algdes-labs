\documentclass{tufte-handout}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{amsmath}

\usepackage{color}
\newcommand{\red}[1]{{\color{red} #1}}
\usepackage{booktabs}

\title{Red Scare! Report}
\author{
  Bjarke Brodin (bjal)\\
  Bjørnar Haugstad Jåtten (bjja)\\
  Helle Friis (hefr)\\
  and Simon Boye Jørgensen (sboj)
}

\begin{document}

\maketitle

\section{Results}

The following table gives my results for all graphs of at least 500 vertices.

\medskip
\begin{tabular}{lrrrrrr}
  \toprule
  Instance name & $n$ & A & F & M & N & S \\
  \midrule
  rusty-5762 & 5,762 & true & 16 & -- & ? & 5 \\
  wall-p-10000 & 10,000 &\\	
  $\vdots$\\
  \bottomrule
\end{tabular}
\medskip

The columns are for the problems Alternate, Few, Many, None, and Some.
The table entries either give the answer, or contain `?' for those cases where I was unable to find a solution within reasonable time.
For those questions where there is a reason for my inability to find a good algorithm (because the problem is hard), I wrote `?!'.

For the complete table of all results, see the tab-separated text file {\tt results.txt}.

\section{Methods}

For all solutions we process the input to produce a graph $G$,
which we assume to be simple.

\subsection{None}
We solve this problem efficiently for all graphs.
Here we did not put any of the red vertex in the graph.
Then when running the shortest path algorithm we were guaranteed
to find the shortest path without any red vertexes in the path
if there exists one.

We use BFS for the shortest path algorithm which has a 
running time of $O((|E| + |V|) \log |V|)$.

\subsection{Alternate}
To solve alternate, we first removed all reflective edges, 
meaning the edges that go from black to black or red to red.
Afterwards, we applied a shortest path algorithm.
If there exists a path between t and s, it must be 
alternating between black and red, as all the relfective edges are removed from the graph.

Running time is dominated by shortest path and is thus simply
$O((|E|+|V|) \log |V|)$.



\subsection{Few}
To solve \textit{few}, 
we realize that we can manipulate edge weights
to allow a reduction to shortest path.
We set weights to 1 for all arcs that 
are incident on a red vertex and all other weights to 0,
then simply run an appropriate shortest path algorithm 
and return the distance.
Running time is dominated by shortest path and is thus simply
$O((|E|+|V|) \log |V|)$.


\subsection{Many}
% much math
\subsection{Some}
%see many - much math

For problem A, I solved each instance $G$ by $\cdots$\footnote{Describe what you did.
  Use words like ``building a inverse anti-tree without self-loops where each vertex in $G$ is presented by a Strogatz--Wasserman shtump.
  I then performed a standard longest hash sorting using the algorithm of Bronf (Algorithm 5 in [1]).''
  Be neat, brief, and precise.}
The running time of this algorithm is $\cdot$, and my implementation spends $\cdots$ seconds on the instance $\cdots$ with  $n=\cdots$.

I solved problem $\cdots$ for all $\cdots$\footnote{For instance, “planar, bipartite”} graphs using $\cdots$.

I was unable to solve problem $\cdots$ except for the $\cdots$ instances.
This is because, in generality, this problem is $\cdots$. 
To see this, consider the following reduction from $\cdots$.
Let $\ldots$ 

I was also unable to solve $\cdots$ for $\cdots$, but I don’t know why.\footnote{Remove or expand as necessary.}

\section{References}
\begin{description}
  \item[1.] \emph{APLgraphlib---A library for Basic Graph Algorithms in APL}, version 2.11, 2016, Iverson Project, {\tt github.com/iverson/APLgraphlib}.\sidenote{If you use references to code, books, or papers, be professional about it. Use whatever style you want, but be consistent.}

  \item[2.] A. Lovelace, \emph{Algorithms and Data Structures in Pascal}, Addison--Wesley 1881. 
\end{description}

\end{document}
